/* document binding for browser using duktape and libdom
 *
 * Copyright 2015 Vincent Sanders <vince@netsurf-browser.org>
 *
 * This file is part of NetSurf, http://www.netsurf-browser.org/
 *
 * Released under the terms of the MIT License,
 *         http://www.opensource.org/licenses/mit-license
 */

class Element {
	prologue %{
%};
}

init Element("struct dom_element *" element::node);

getter Element::firstElementChild()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *next_node;

	exc = dom_node_get_first_child(((node_private_t*)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_next_sibling(element, &next_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = next_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::lastElementChild()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *next_node;

	exc = dom_node_get_last_child(((node_private_t*)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_previous_sibling(element, &next_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = next_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::previousElementSibling()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *sib_node;

	exc = dom_node_get_previous_sibling(((node_private_t *)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_previous_sibling(element, &sib_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = sib_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::nextElementSibling()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *sib_node;

	exc = dom_node_get_next_sibling(((node_private_t *)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_next_sibling(element, &sib_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = sib_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::childElementCount()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *next_node;
	duk_uint_t jsret = 0;

	exc = dom_node_get_first_child(((node_private_t *)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			jsret += 1;
		}

		exc = dom_node_get_next_sibling(element, &next_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = next_node;
		} else {
			element = NULL;
		}
	}
	LOG("I found %u of them", jsret);
	duk_push_uint(ctx, jsret);
	return 1;
%}
